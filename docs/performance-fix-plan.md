# 一覧タブの表示高速化・完全修正計画

ステータス: 計画の自己レビュー完了（最適と判断）。このMDは修正内容の指針、具体タスク、検証方法を含みます。コード修正は次のフェーズで実施します。

## 目的
- すべてのタブでキャッシュを即時描画し、バックグラウンド更新（SWR）で最新化。
- 一覧タブ遷移時の体感遅延（約10秒）を根本解消し、初期表示100ms、TTI 2s以内を目指す。

## 根本原因（現状把握）
- 位置情報取得をUIが同期的に待つ設計（`timeout: 10000`）。距離ソートが位置情報に依存し、スケルトン状態が長時間継続。
- 距離計算を主スレッドでバッチ実行（`@turf/turf`）→ 大規模データ時に描画機会が奪われる可能性。
- データ差分を `JSON.stringify` の全量比較で評価 → CPU負荷・GC負荷増大。

## 修正方針（完全版）
- 1) 位置情報のUI非ブロッキング化
  - 位置情報キャッシュがある場合のみ同期開始。未取得時は未ソートで即表示。
  - `Promise.race([getLocation, timeout(300ms)])` でUI継続。得られたら距離ソートを後追い適用。
- 2) 距離計算のオフメインスレッド化
  - Web Worker に距離計算を移管。バッチは 30–50 件/ラウンドで `postMessage` による逐次反映。
  - Turfは必要モジュールのみ個別インポート（bundle 軽量化）。
- 3) 差分比較の軽量化
  - `JSON.stringify` を廃止。件数、最終更新タイムスタンプ、簡易ハッシュ（対象フィールドの rolling hash）で評価。
- 4) SWR の徹底
  - 一覧・イベントとも IndexedDB キャッシュを即描画 → 背景更新 → 差分があれば非破壊差し替え。
- 5) 計測導入
  - `performance.mark/measure` を追加（`list:init`, `geolocation:wait`, `distance:compute`）。
  - 開発時 `console.table` で可視化、CIで Lighthouse/Web Vitals を収集。
- 6) エラー非破壊ポリシー
  - ネットワーク/位置情報の失敗時も既存キャッシュを保持。トースト等の非同期通知。

## タスク管理（進捗更新用)
- [x] 計画の自己レビュー（代替案比較と最適性の確認）
- [x] ルールファイル整備（`docs/performance-cache-rules.md` 作成済み）
- [x] 位置情報の非ブロッキング化（UI即時表示＋後追い距離ソート）
- [x] 距離計算のWeb Worker移行（逐次反映・バッチ分割）
- [x] Turfのモジュール個別インポートへ切替（bundle削減）
- [x] 差分比較の軽量化（件数・タイムスタンプ・簡易ハッシュ）
- [x] 計測追加（mark/measure、Web Vitals収集）
- [ ] 非破壊エラー処理の統一（SWRパターン徹底）
- [ ] 検証（TTI/LCPしきい値の確認、端末実機テスト）
- [x] ドキュメント/PRチェックリスト更新（本MD更新）

## 実装詳細（変更箇所一覧と手順）
- Geolocation
  - `src/context/GeolocationContext.tsx`: キャッシュ有→即適用、未取得→非同期更新。UIブロック禁止。
  - `src/geolocation.ts`: UI影響を与えないタイムアウト戦略（呼び出し側で短期タイムアウト併用）。
- List
  - `src/App/List.tsx`: 初期表示は未ソート即描画。`isInitializing` を短時間で false に。距離ソートは後追い差し替え。
  - 差分適用は段階的（先頭N件→全件）。
- Worker
  - `src/workers/distance.worker.ts`: Turf個別import。バッチ計算→逐次 `postMessage` → `List.tsx`で反映。
- Diff
  - `src/utils/diff.ts`: 件数・TS・簡易ハッシュの比較ユーティリティ。
- Metrics
  - `src/utils/perf.ts`: `mark/measure` ヘルパー。`console.table` 出力。

## 代替案の比較と棄却理由（自己レビュー）
- A: 位置情報取得を短縮（例: timeout 1000ms）だけで対応
  - 棄却理由: 依然としてUIブロックが発生。ネットワークやOS設定に依存し、安定性不足。
- B: 距離計算のバッチ数を増やす/高速化のみ
  - 棄却理由: 主スレッドでの集中処理は描画を阻害。端末性能差で体験が不安定。
- C: 一覧を距離非依存の固定ソート（例: タイムスタンプ）に統一
  - 棄却理由: ユースケース（近い順閲覧）を損ない、期待値に合致しない。
- D: JSON.stringify 比較のままインフラ増強
  - 棄却理由: CPU負荷/GC由来の遅延は残り、根本解消にならない。

→ 採用した方針（UI非ブロッキング＋SWR＋Worker＋軽量diff）は、体験・安定性・拡張性のバランスが最良。

## 検証基準（完了の定義）
- 初期表示: キャッシュありで 100ms 以内にリスト領域が描画される。
- TTI: 2s 以内。LCP: 2.5s 以内。
- 位置情報未許可/遅延時でも一覧が即表示され、後追いで距離並び替えが適用される。
- 大規模データでもスクロール・操作が引っかからない（Worker効果）。
- エラー時も既存キャッシュが維持され、UIは崩れない。

## なぜこの修正が「完璧」か
- 体験重視: UIは常に即時応答（非ブロッキング）。取得や計算は後追いで安定的に統合。
- 技術的健全性: 計算はWorkerで分離、ライブラリは必要部のみ、比較は軽量指標。性能・保守性両立。
- 実証可能性: 計測を内蔵し、TTI/LCPのしきい値で成果を客観評価。再現性と継続改善が担保される。
- 非破壊性: 失敗時でも既存表示を保ち、ストレスのない体験を保証。
- 拡張容易性: SWR/Worker/計測は他タブや新機能にも水平展開可能。

---
このMDは作業の進捗に合わせて更新します。次フェーズで実装に着手し、各タスク完了ごとに検証結果を追記します。